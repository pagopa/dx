"use strict";var p=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(e,t)=>{for(var r in t)a(e,r,{get:t[r],enumerable:!0})},d=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of w(t))!b.call(e,i)&&i!==r&&a(e,i,{get:()=>t[i],enumerable:!(o=h(t,i))||o.enumerable});return e};var l=(e,t,r)=>(r=e!=null?p(y(e)):{},d(t||!e||!e.__esModule?a(r,"default",{value:e,enumerable:!0}):r,e)),C=e=>d(a({},"__esModule",{value:!0}),e);var S={};v(S,{run:()=>g});module.exports=C(S);var n=l(require("@actions/core"),1),u=l(require("@actions/github"),1),f=require("fs"),c=require("path");function B(){let e=n.getInput("comment-body"),t=n.getInput("comment-body-file"),r=n.getInput("search-pattern");if(!e&&!t)throw new Error("Either comment-body or comment-body-file must be provided");return{commentBody:e||void 0,commentBodyFile:t||void 0,searchPattern:r||void 0}}function E(){let{context:e}=u;if(!e.issue.number)throw new Error("This action can only be run on pull requests");return{issueNumber:e.issue.number,owner:e.repo.owner,repo:e.repo.repo}}function F(e){let t=(0,c.resolve)(e),r=process.cwd(),o=(0,c.relative)(r,t);if(o.startsWith("..")||(0,c.resolve)(r,o)!==t)throw new Error(`File path "${e}" is outside the allowed directory. Only files within the current working directory are allowed.`);let i=["/etc/","/proc/","/sys/","/.ssh/","/.env","/tmp/","id_rsa","id_dsa","authorized_keys","known_hosts"],m=t.toLowerCase();for(let s of i)if(m.includes(s))throw new Error(`File path "${e}" contains potentially sensitive pattern "${s}".`)}function P(e){if(e.commentBody)return e.commentBody;if(e.commentBodyFile)try{return F(e.commentBodyFile),(0,f.readFileSync)(e.commentBodyFile,"utf8")}catch(t){throw new Error(`Failed to read comment body file: ${e.commentBodyFile}. Error: ${t instanceof Error?t.message:String(t)}`)}throw new Error("No comment body content available")}async function $(e,t,r){try{n.info(`Searching for existing comments with pattern: "${r}"`);let o=await e.paginate(e.rest.issues.listComments,{issue_number:t.issueNumber,owner:t.owner,repo:t.repo,per_page:100}),i=r.trim().toLowerCase(),m=o.filter(s=>s.body?.toLowerCase().includes(i));n.info(`Found ${m.length} matching comments to delete`);for(let s of m)await e.rest.issues.deleteComment({comment_id:s.id,owner:t.owner,repo:t.repo}),n.info(`Deleted comment with ID: ${s.id}`)}catch(o){n.warning(`Failed to delete existing comments: ${o instanceof Error?o.message:String(o)}`)}}async function I(e,t,r){try{let{data:o}=await e.rest.issues.createComment({body:r,issue_number:t.issueNumber,owner:t.owner,repo:t.repo});n.info(`Successfully created comment with ID: ${o.id}`),n.setOutput("comment-id",o.id.toString()),n.setOutput("comment-url",o.html_url)}catch(o){throw new Error(`Failed to create comment: ${o instanceof Error?o.message:String(o)}`)}}async function g(){try{n.info("Starting PR Comment Manager Action");let e=B();n.info("Successfully validated inputs");let t=E();n.info(`Running on PR #${t.issueNumber} in ${t.owner}/${t.repo}`);let r=n.getInput("github-token")||process.env.GITHUB_TOKEN;if(!r)throw new Error("GitHub token not found. Please provide github-token input or GITHUB_TOKEN environment variable");let o=u.getOctokit(r),i=P(e);n.info("Successfully resolved comment body content"),e.searchPattern&&await $(o,t,e.searchPattern),await I(o,t,i),n.info("PR Comment Manager Action completed successfully")}catch(e){let t=e instanceof Error?e.message:String(e);n.setFailed(`Action failed: ${t}`)}}require.main===module&&g();0&&(module.exports={run});
//# sourceMappingURL=index.cjs.map