{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @fileoverview PR Comment Manager Action\n *\n * This module provides functionality to create and manage comments on GitHub Pull Requests.\n * It can create new comments or update existing ones based on a search pattern.\n */\n\nimport * as core from \"@actions/core\";\nimport * as github from \"@actions/github\";\nimport { readFileSync } from \"fs\";\nimport { resolve, relative } from \"path\";\n\n/**\n * Input parameters for the PR comment action\n */\ninterface ActionInputs {\n  /** The comment content to post (supports markdown) */\n  commentBody?: string;\n  /** Path to a file containing the comment content */\n  commentBodyFile?: string;\n  /** Text pattern to identify existing comments to delete */\n  searchPattern?: string;\n}\n\n/**\n * GitHub context information needed for API calls\n */\ninterface GitHubContext {\n  issueNumber: number;\n  owner: string;\n  repo: string;\n}\n\n/**\n * Gets and validates the action inputs\n * @returns Validated action inputs\n * @throws Error if validation fails\n */\nfunction getInputs(): ActionInputs {\n  const commentBody = core.getInput(\"comment-body\");\n  const commentBodyFile = core.getInput(\"comment-body-file\");\n  const searchPattern = core.getInput(\"search-pattern\");\n\n  // Validate that at least one content source is provided\n  if (!commentBody && !commentBodyFile) {\n    throw new Error(\n      \"Either comment-body or comment-body-file must be provided\",\n    );\n  }\n\n  return {\n    commentBody: commentBody || undefined,\n    commentBodyFile: commentBodyFile || undefined,\n    searchPattern: searchPattern || undefined,\n  };\n}\n\n/**\n * Gets the GitHub context information\n * @returns GitHub context with owner, repo, and issue number\n * @throws Error if not running in a pull request context\n */\nfunction getGitHubContext(): GitHubContext {\n  const { context } = github;\n\n  if (!context.issue.number) {\n    throw new Error(\"This action can only be run on pull requests\");\n  }\n\n  return {\n    issueNumber: context.issue.number,\n    owner: context.repo.owner,\n    repo: context.repo.repo,\n  };\n}\n\n/**\n * Validates that a file path is safe to read\n * @param filePath - The file path to validate\n * @throws Error if the path is unsafe\n */\nfunction validateFilePath(filePath: string): void {\n  // Resolve the absolute path\n  const absolutePath = resolve(filePath);\n\n  // Get the current working directory\n  const cwd = process.cwd();\n\n  // Check if the resolved path is within the current working directory\n  const relativePath = relative(cwd, absolutePath);\n\n  // Prevent directory traversal attacks\n  if (\n    relativePath.startsWith(\"..\") ||\n    resolve(cwd, relativePath) !== absolutePath\n  ) {\n    throw new Error(\n      `File path \"${filePath}\" is outside the allowed directory. Only files within the current working directory are allowed.`,\n    );\n  }\n\n  // Additional security: block common sensitive file patterns\n  const sensitivePatterns = [\n    \"/etc/\",\n    \"/proc/\",\n    \"/sys/\",\n    \"/.ssh/\",\n    \"/.env\",\n    \"/tmp/\",\n    \"id_rsa\",\n    \"id_dsa\",\n    \"authorized_keys\",\n    \"known_hosts\",\n  ];\n\n  const normalizedPath = absolutePath.toLowerCase();\n  for (const pattern of sensitivePatterns) {\n    if (normalizedPath.includes(pattern)) {\n      throw new Error(\n        `File path \"${filePath}\" contains potentially sensitive pattern \"${pattern}\".`,\n      );\n    }\n  }\n}\n\n/**\n * Resolves the comment body content from either direct input or file\n * @param inputs - The action inputs\n * @returns The comment body content\n */\nfunction resolveCommentBody(inputs: ActionInputs): string {\n  if (inputs.commentBody) {\n    return inputs.commentBody;\n  }\n\n  if (inputs.commentBodyFile) {\n    try {\n      // Validate the file path for security\n      validateFilePath(inputs.commentBodyFile);\n\n      return readFileSync(inputs.commentBodyFile, \"utf8\");\n    } catch (error) {\n      throw new Error(\n        `Failed to read comment body file: ${inputs.commentBodyFile}. Error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  throw new Error(\"No comment body content available\");\n}\n\n/**\n * Deletes existing comments that match the search pattern\n * @param octokit - GitHub API client\n * @param context - GitHub context information\n * @param searchPattern - Pattern to search for in existing comments\n */\nasync function deleteMatchingComments(\n  octokit: ReturnType<typeof github.getOctokit>,\n  context: GitHubContext,\n  searchPattern: string,\n): Promise<void> {\n  try {\n    core.info(\n      `Searching for existing comments with pattern: \"${searchPattern}\"`,\n    );\n\n    // Use paginate to fetch all comments\n    const comments = await octokit.paginate(octokit.rest.issues.listComments, {\n      issue_number: context.issueNumber,\n      owner: context.owner,\n      repo: context.repo,\n      per_page: 100, // Increase per_page for efficiency\n    });\n\n    // Normalize pattern for robust comparison (case-insensitive)\n    const normalizedPattern = searchPattern.trim().toLowerCase();\n\n    const matchingComments = comments.filter((comment) =>\n      comment.body?.toLowerCase().includes(normalizedPattern),\n    );\n\n    core.info(`Found ${matchingComments.length} matching comments to delete`);\n\n    for (const comment of matchingComments) {\n      await octokit.rest.issues.deleteComment({\n        comment_id: comment.id,\n        owner: context.owner,\n        repo: context.repo,\n      });\n      core.info(`Deleted comment with ID: ${comment.id}`);\n    }\n  } catch (error) {\n    core.warning(\n      `Failed to delete existing comments: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\n/**\n * Creates a new comment on the pull request\n * @param octokit - GitHub API client\n * @param context - GitHub context information\n * @param body - The comment body content\n */\nasync function createComment(\n  octokit: ReturnType<typeof github.getOctokit>,\n  context: GitHubContext,\n  body: string,\n): Promise<void> {\n  try {\n    const { data: comment } = await octokit.rest.issues.createComment({\n      body,\n      issue_number: context.issueNumber,\n      owner: context.owner,\n      repo: context.repo,\n    });\n\n    core.info(`Successfully created comment with ID: ${comment.id}`);\n    core.setOutput(\"comment-id\", comment.id.toString());\n    core.setOutput(\"comment-url\", comment.html_url);\n  } catch (error) {\n    throw new Error(\n      `Failed to create comment: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\n/**\n * Main action logic\n */\nasync function run(): Promise<void> {\n  try {\n    core.info(\"Starting PR Comment Manager Action\");\n\n    // Get and validate inputs\n    const inputs = getInputs();\n    core.info(\"Successfully validated inputs\");\n\n    // Get GitHub context\n    const context = getGitHubContext();\n    core.info(\n      `Running on PR #${context.issueNumber} in ${context.owner}/${context.repo}`,\n    );\n\n    // Get GitHub token and create client\n    const token = core.getInput(\"github-token\") || process.env.GITHUB_TOKEN;\n    if (!token) {\n      throw new Error(\n        \"GitHub token not found. Please provide github-token input or GITHUB_TOKEN environment variable\",\n      );\n    }\n\n    const octokit = github.getOctokit(token);\n\n    // Resolve comment body content\n    const commentBody = resolveCommentBody(inputs);\n    core.info(\"Successfully resolved comment body content\");\n\n    // Delete existing comments if search pattern is provided\n    if (inputs.searchPattern) {\n      await deleteMatchingComments(octokit, context, inputs.searchPattern);\n    }\n\n    // Create new comment\n    await createComment(octokit, context, commentBody);\n\n    core.info(\"PR Comment Manager Action completed successfully\");\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    core.setFailed(`Action failed: ${errorMessage}`);\n  }\n}\n\n// Run the action\nif (require.main === module) {\n  run();\n}\n\nexport { run };\n"],"mappings":"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","names":["index_exports","__export","run","__toCommonJS","core","github","import_fs","import_path","getInputs","commentBody","commentBodyFile","searchPattern","getGitHubContext","context","validateFilePath","filePath","absolutePath","cwd","relativePath","sensitivePatterns","normalizedPath","pattern","resolveCommentBody","inputs","error","deleteMatchingComments","octokit","comments","normalizedPattern","matchingComments","comment","createComment","body","token","errorMessage"]}