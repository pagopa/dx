"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9078],{4718:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>d});var s=i(3309);const t={},r=s.createContext(t);function c(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(r.Provider,{value:n},e.children)}},8620:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"conventions/npm-scripts","title":"Naming Convention for npm Scripts","description":"Context","source":"@site/docs/conventions/npm-scripts.md","sourceDirName":"conventions","slug":"/conventions/npm-scripts","permalink":"/dx/pr-preview/pr-518/docs/conventions/npm-scripts","draft":false,"unlisted":false,"editUrl":"https://github.com/pagopa/dx/tree/main/website/docs/conventions/npm-scripts.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"Naming Convention for npm Scripts"},"sidebar":"tutorialSidebar","previous":{"title":"Infrastructure Folder Structure","permalink":"/dx/pr-preview/pr-518/docs/conventions/infra-folder-structure"},"next":{"title":"Git","permalink":"/dx/pr-preview/pr-518/docs/conventions/git/"}}');var t=i(3881),r=i(4718);const c={sidebar_position:3,sidebar_label:"Naming Convention for npm Scripts"},d="Naming Convention for npm Scripts",o={},l=[{value:"Context",id:"context",level:2},{value:"Examples of Script Naming",id:"examples-of-script-naming",level:3},{value:"Guidelines for npm Scripts",id:"guidelines-for-npm-scripts",level:2}];function a(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"naming-convention-for-npm-scripts",children:"Naming Convention for npm Scripts"})}),"\n",(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:'Node.js compatible package managers, such as npm and Yarn, support the\ndefinition of "package scripts," which function as simple task runners. However,\nwithout shared guidelines for naming and structuring these scripts, several\nissues arise:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Projects have inconsistent naming for scripts (e.g., ",(0,t.jsx)(n.code,{children:"watch"}),", ",(0,t.jsx)(n.code,{children:"build:watch"}),",\n",(0,t.jsx)(n.code,{children:"docker-start"}),", etc.), making it harder to onboard engineers or write\nabstractions (like pipelines) that work across multiple projects."]}),"\n",(0,t.jsx)(n.li,{children:"Many scripts are overly complex or trigger unintended side effects, making\nmaintenance difficult."}),"\n",(0,t.jsx)(n.li,{children:"Some scripts rely on external tools (e.g., Docker) not handled by the package\nmanager, which adds configuration overhead."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To resolve these issues, adopting a consistent naming convention and following a\nset of guidelines is proposed."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:'By adopting a naming convention for package scripts, we can enforce a common\ninterface for all projects. This "Convention over Configuration" approach\nsimplifies writing project-agnostic abstractions like CI pipelines.'})}),"\n",(0,t.jsx)(n.h3,{id:"examples-of-script-naming",children:"Examples of Script Naming"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Script Name"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Example Implementation"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"start"})}),(0,t.jsxs)(n.td,{children:["Runs the Node.js application defined in ",(0,t.jsx)(n.code,{children:"package.json"}),"."]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"node ."})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"test"})}),(0,t.jsx)(n.td,{children:"Executes unit tests."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"vitest run"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"test:coverage"})}),(0,t.jsx)(n.td,{children:"Runs unit tests and generates code coverage reports."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"vitest run --coverage"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"build"})}),(0,t.jsx)(n.td,{children:"Compiles the project for production."}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"tsc"}),", ",(0,t.jsx)(n.code,{children:"next build"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"build:watch"})}),(0,t.jsx)(n.td,{children:"Watches for file changes and rebuilds the project."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"build --watch"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"typecheck"})}),(0,t.jsx)(n.td,{children:"Performs type checking on TypeScript code."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tsc --noEmit"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"bundle"})}),(0,t.jsx)(n.td,{children:"Packages the project into a deployable format (e.g., ZIP)."}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"npm-pack-zip"}),", ",(0,t.jsx)(n.code,{children:"yarn bundle"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"format"})}),(0,t.jsx)(n.td,{children:"Formats the project's files according to the style guide."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"prettier --write ."})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"format:check"})}),(0,t.jsx)(n.td,{children:"Verifies adherence to the style guide without reformatting."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"prettier --check ."})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"lint"})}),(0,t.jsx)(n.td,{children:"Lints the code and fixes auto-fixable issues."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'eslint --fix "src/**"'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"lint:check"})}),(0,t.jsx)(n.td,{children:"Lints the code without applying fixes."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'eslint "src/**"'})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"generate:<name>"})}),(0,t.jsx)(n.td,{children:"Generates files needed by the project (e.g., API models)."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"gen-api-models --api-spec ./openapi.yaml --out-dir ./src/infra/http/models"})})]})]})]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Projects are not required to implement ",(0,t.jsx)(n.em,{children:"all"})," of these scripts. Instead, focus on\nmaintaining consistent naming. For example, use ",(0,t.jsx)(n.code,{children:"format"})," instead of ",(0,t.jsx)(n.code,{children:"prettify"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"guidelines-for-npm-scripts",children:"Guidelines for npm Scripts"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Self-contained commands:"})," All commands in scripts should be executable\nafter installing dependencies via ",(0,t.jsx)(n.code,{children:"npm install"})," or ",(0,t.jsx)(n.code,{children:"yarn"}),". They should not\nrely on globally installed tools (e.g., ",(0,t.jsx)(n.code,{children:"brew"}),", ",(0,t.jsx)(n.code,{children:"pip"}),"). If external tools are\nneeded, use a task runner (e.g., ",(0,t.jsx)(n.code,{children:"make"}),") to wrap the scripts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simplicity and atomicity:"})," Scripts should be as simple as possible. If a\nscript becomes too complex, consider moving it to a separate JavaScript file.\nKeep scripts atomic, meaning they should focus on doing one task at a time."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Avoid lifecycle hooks:"})," Hooks like ",(0,t.jsx)(n.code,{children:"prebuild"})," or ",(0,t.jsx)(n.code,{children:"postinstall"})," introduce\nside effects and slow down the developer experience. For instance, running\n",(0,t.jsx)(n.code,{children:"build"})," should not always trigger ",(0,t.jsx)(n.code,{children:"generate"})," if it\u2019s not necessary."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Limit ",(0,t.jsx)(n.code,{children:"npm-run-all"})," usage:"]})," Scripts should perform one task only. Leave\nthe decision of what to run up to the developer, rather than chaining\ncommands excessively with ",(0,t.jsx)(n.code,{children:"npm-run-all"}),". If advanced task coordination is\nneeded, use tools like ",(0,t.jsx)(n.code,{children:"turborepo"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);