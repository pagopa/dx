on:
  workflow_call:
    inputs:
      dockerfile_path:
        type: string
        required: false
        default: './Dockerfile'
        description: Dockerfile path
      dockerfile_context:
        type: string
        required: false
        default: '.'
        description: Dockerfile build context
      docker_image_name:
        type: string
        required: false
        default: ${{ github.repository }}
        description: Docker image name, defaults to repository name
      image_description:
        type: string
        required: true
        description: A description to use as image label
      image_authors:
        type: string
        required: false
        default: PagoPA
        description: Authors names to use as image label
      build_args:
        description: List of build arguments to use for Dockerfile build, given in env=value format.
        type: string
        required: false
      build_platforms:
        type: string
        required: false
        default: linux/amd64
        description: Image runtime platform, supports multiple values
      container_app:
        type: string
        required: true
        description: Name of the container app to deploy
      resource_group_name:
        type: string
        required: true
        description: Name of the resource group of the container app
      # override_github_environment:
      #   description: Set a value if GitHub Environment name is different than the TF environment folder
      #   type: string
      #   required: false
      #   default: ''

concurrency:
  group: ${{ github.workflow }}-cd
  cancel-in-progress: true

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    if: ${{ false }} # ${{ !github.event.act }}

    steps:

      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        name: Checkout

      - name: Docker Build and Push
        uses: pagopa/dx/.github/actions/docker-build-push@main
        with:
          dockerfile_path: ${{ inputs.dockerfile_path }}
          dockerfile_context: ${{ inputs.dockerfile_context }}
          docker_image_name: ${{ inputs.docker_image_name }}
          image_description: ${{ inputs.image_description }}
          image_authors: ${{ inputs.image_authors }}
          build_args: ${{ inputs.build_args }}
          build_platforms: ${{ inputs.build_platforms }}
          push_to_registry: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release:
    name: Deploy To Container App
    runs-on: ubuntu-latest
    # environment: ${{ inputs.override_github_environment == '' && 'prod' || inputs.override_github_environment}}-cd
    # needs: build
    permissions:
      id-token: write
      contents: read
    env:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CONTAINER_APP_NAME: ${{ inputs.container_app }}
      RESOURCE_GROUP_NAME: ${{ inputs.resource_group_name }}

    steps:

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Get Short SHA of Latest Commit
        id: get_commit_sha
        run: |
          sha=$(git rev-parse --short HEAD)

          echo "Found SHA: $sha"

          echo "short_sha=$sha" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: pagopa/dx/.github/actions/azure-login@main

      - name: Install containerapp AZ CLI Extension
        run: |
          az extension add -n containerapp --yes --allow-preview

      - name: Get Container App Resource Id
        id: get_container_app_id
        run: |
          ca_id=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --query "id" \
            --output tsv)

          echo "Container App resource Id: $ca_id"

          echo "container_app_id=$ca_id" >> $GITHUB_OUTPUT

      - name: Ensure Latest Revision Captures All Traffic
        id: ensure_latest_revision
        run: |
          # this step is also useful to ensure new revisions will not have 100% of the traffic (default behavior)
          current_revision=$(az containerapp revision list \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
            --query 'reverse(sort_by([].{Revision:name,Active:properties.active,Created:properties.createdTime}[?Active!=`false`], &Created))| [0].Revision' -o tsv)

          echo "Current revision: $current_revision"

          az containerapp ingress traffic set \
            --ids "${{ steps.get_container_app_id.outputs.container_app_id }}" \
            --revision-weight $current_revision=100

          echo "current_revision_name=$current_revision" >> $GITHUB_OUTPUT

      - name: Create New Revision
        id: create_new_revision
        env:
          DOCKER_IMAGE_NAME: ${{ inputs.docker_image_name }}
        run: |
          new_revision=$(az containerapp revision copy \
            --ids "${{ steps.get_container_app_id.outputs.container_app_id }}" \
            --from-revision ${{ steps.ensure_latest_revision.outputs.current_revision_name }} \
            --image ${{ env.DOCKER_IMAGE_NAME }} \
            --revision-suffix ${{steps.get_commit_sha.outputs.short_sha}} \
            --query "properties.latestRevisionName" \
            --output tsv)

          echo "New revision: $new_revision"

          echo "new_revision_name=$new_revision" >> $GITHUB_OUTPUT

      - name: Wait for New Revision to Become Ready
        run: |
            max_attempts=60
            attempt=0
            health_state=""
            new_revision_name="${{ steps.create_new_revision.outputs.new_revision_name }}"

            echo "Waiting for new revision to become healthy..."

            while [ "$health_state" != "Healthy" ] && [ $attempt -lt $max_attempts ]; do

              health_state=$(az containerapp revision list \
                --name ${{ env.CONTAINER_APP_NAME }} \
                --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
                --query "[?contains(name, '$new_revision_name')].{Health:properties.healthState}|[0].Health" -o tsv)

              echo "Current health state: $health_state (attempt $((attempt+1))/$max_attempts)"

              if [ "$health_state" == "Healthy" ]; then
                echo "New revision is now healthy!"
                break
              fi

              attempt=$((attempt+1))
              sleep 1
            done

            if [ "$health_state" != "Healthy" ]; then
              echo "Error: New revision did not become healthy within the timeout period"
              exit 1
            fi

      - name: Check for errors and increment traffic
        env:
          CONTAINER_APP_ID: "${{ steps.get_container_app_id.outputs.container_app_id }}"
        run: |
          new_revision_name=${{ steps.create_new_revision.outputs.new_revision_name }}

          for percentage in 5 10 30 50 70 90 100
          do
            echo "Setting $new_revision_name traffic to $percentage%"

            az containerapp ingress traffic set \
              --ids "$CONTAINER_APP_ID" \
              --revision-weight ${{ steps.ensure_latest_revision.outputs.current_revision_name }}=$(100-$percentage) \
              --revision-weight "$new_revision_name=$percentage"

            echo "Waiting 90 seconds before checking health and increasing traffic..."
            sleep 90

            # Check for error logs
            error_count=$(az containerapp logs show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP_NAME }} \
              --revision $new_revision_name \
              --tail 100 \
              # --only-show-errors \
              --format json \
              --query "length([?contains(log, 'error') || contains(log, 'Error') || contains(log, 'ERROR') || contains(log, 'exception') || contains(log, 'Exception')])" \
              --output tsv)

            # Check HTTP errors rate (5xx)
            http_errors=$(az monitor metrics list \
              --resource "$CONTAINER_APP_ID" \
              --metric "HttpResponseStatus5xx" \
              --interval 1m \
              --aggregation Total \
              --output tsv \
              --query 'value[0].timeseries[0].data[0].total' 2>/dev/null || echo "0")

            # Check revision health state
            health_state=$(az containerapp revision list \
              --ids "$CONTAINER_APP_ID" \
              --query "[?name=='$blue_revision'].properties.healthState" -o tsv)

            echo "Health check results:"
            echo "- Error logs: $error_count"
            echo "- HTTP 5xx errors: $http_errors"
            echo "- Health state: $health_state"

            # If any errors or unhealthy state, rollback and exit
            if [ "$error_count" -gt 0 ] || [ "$http_errors" -gt 0 ] || [ "$health_state" != "Healthy" ]; then
              echo "Errors detected in revision '$new_revision_name', rolling back to previous revision"

              az containerapp ingress traffic set \
                --ids "$CONTAINER_APP_ID" \
                --label-revision latest=100"

              exit 1
            fi

          echo "No errors detected, continuing traffic shift"
            done

            echo "Successfully shifted 100% traffic to new revision"

      - name: Deactivate old revision
        run: |
          az containerapp revision deactivate \
            --ids "$CONTAINER_APP_ID" \
            --revision latest
