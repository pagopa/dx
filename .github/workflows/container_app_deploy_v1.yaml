on:
  workflow_call:
    inputs:
      dockerfile_path:
        type: string
        required: false
        default: './Dockerfile'
        description: Dockerfile path
      dockerfile_context:
        type: string
        required: false
        default: '.'
        description: Dockerfile build context
      docker_image_name:
        type: string
        required: false
        default: ${{ github.repository }}
        description: Docker image name, defaults to repository name
      docker_image_description:
        type: string
        required: true
        description: A description to use as image label
      docker_image_authors:
        type: string
        required: false
        default: PagoPA
        description: Authors names to use as image label
      build_args:
        description: List of build arguments to use for Dockerfile build, given in env=value format.
        type: string
        required: false
      build_platforms:
        type: string
        required: false
        default: linux/amd64
        description: Image runtime platform, supports multiple values
      container_app:
        type: string
        required: true
        description: Name of the container app to deploy
      resource_group_name:
        type: string
        required: true
        description: Name of the resource group of the container app
      apply_github_tags_to_image_tags:
        type: boolean
        required: false
        default: false
        description: Use GitHub tags for image tagging
      environment:
        description: Environment where the image will be deployed.
        type: string
        required: true
      # npm_script:
      #   type: string
      #   required: false
      #   description: NPM script to run to check for errors

concurrency:
  group: ${{ github.workflow }}-cd
  cancel-in-progress: true

env:
  IMAGE_NAME: ${{ inputs.docker_image_name }}
  # NPM_SCRIPT: ${{ inputs.npm_script }}

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      attestations: write
      packages: write

    steps:

      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        name: Checkout

      - name: Docker Build and Push
        id: docker_build
        uses: pagopa/dx/.github/actions/docker-build-push@CES-958-definire-una-pipeline-di-cd-per-le-container-app
        with:
          dockerfile_path: ${{ inputs.dockerfile_path }}
          dockerfile_context: ${{ inputs.dockerfile_context }}
          docker_image_name: ${{ env.IMAGE_NAME }}
          docker_image_description: "${{ inputs.docker_image_description }}"
          docker_image_authors: ${{ inputs.docker_image_authors }}
          build_args: ${{ inputs.build_args }}
          build_platforms: ${{ inputs.build_platforms }}
          push_to_registry: true
          apply_github_tags_to_image_tags: ${{ inputs.apply_github_tags_to_image_tags}}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release:
    name: Deploy To Container App
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ inputs.environment }}-cd
    permissions:
      contents: read
      id-token: write
    env:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CONTAINER_APP_NAME: ${{ inputs.container_app }}
      RESOURCE_GROUP_NAME: ${{ inputs.resource_group_name }}

    steps:

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Get Short SHA of Latest Commit
        id: get_commit_sha
        run: |
          sha=$(git rev-parse --short ${{ github.sha }})

          echo "Latest commit sha: $sha"

          echo "short_sha=$sha" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: pagopa/dx/.github/actions/azure-login@main

      - name: Allow AZ CLI Extensions
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt

      - name: Set Default Resource Group
        run: |
          az configure --defaults group=${{ env.RESOURCE_GROUP_NAME }}

      # - name: Get Log Analytics Workspace ID
      #   id: get_log_analytics_workspace_id
      #   run: |
      #     cae_id=$(az containerapp show \
      #       --name ${{ env.CONTAINER_APP_NAME }} \
      #       --query "properties.environmentId")

      #     workspace_id=$(az containerapp env show \
      #       --ids $cae_id \
      #       --query "properties.appLogsConfiguration.logAnalyticsConfiguration.customerId")

      #     echo "log_analytics_workspace_id=$workspace_id" >> $GITHUB_OUTPUT

      - name: Get Container App Revision Mode
        id: get_revision_mode
        run: |
          revision_mode=$(az containerapp show \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --query "properties.configuration.activeRevisionsMode" \
            --output tsv)

          echo "Revision mode: $revision_mode"

          echo "ca_revision_mode=$revision_mode" >> $GITHUB_OUTPUT

          echo "revision_mode=$revision_mode" >> $GITHUB_OUTPUT

      - name: Deploy New Image
        if: ${{ steps.get_revision_mode.outputs.revision_mode == 'Single' }}
        run: |
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --image "ghcr.io/${{ env.IMAGE_NAME }}:sha-${{ steps.get_commit_sha.outputs.short_sha }}"

      - name: Get Container App Current Revision
        id: get_current_revision
        if: ${{ steps.get_revision_mode.outputs.revision_mode == 'Multiple' }}
        run: |
          current_revision=$(az containerapp revision list \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --query 'reverse(sort_by([].{Revision:name,Active:properties.active,Created:properties.createdTime}[?Active!=`false`], &Created))| [0].Revision' -o tsv)

          echo "current_revision_name=$current_revision" >> $GITHUB_OUTPUT

      - name: Create New Container App Revision
        id: create_new_revision
        if: ${{ steps.get_revision_mode.outputs.revision_mode == 'Multiple' }}
        env:
          CURRENT_REVISION: ${{ steps.get_current_revision.outputs.current_revision_name }}
        run: |
          new_revision=$(az containerapp revision copy \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --image "ghcr.io/${{ env.IMAGE_NAME }}:sha-${{ steps.get_commit_sha.outputs.short_sha }}" \
            --from-revision ${{ env.CURRENT_REVISION }} \
            --query "properties.latestRevisionName" \
            --output tsv)

          echo "Current revision: ${{ env.CURRENT_REVISION }}"
          echo "New revision: $new_revision"

          if [[ "${{ env.CURRENT_REVISION }}" == "$new_revision" ]]; then
            echo "::warning::No deployment needed - current revision is already using the latest image"
            echo "skip_remaining_steps=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "new_revision_name=$new_revision" >> $GITHUB_OUTPUT
          echo "skip_remaining_steps=false" >> $GITHUB_OUTPUT

          az containerapp ingress traffic set \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --revision-weight ${{ env.CURRENT_REVISION }}=100 \
            --revision-weight $new_revision=0 \
            --output table

      - name: Wait for New Revision to Become Ready
        if: ${{ steps.get_revision_mode.outputs.revision_mode == 'Multiple' && steps.create_new_revision.outputs.skip_remaining_steps == 'false' }}
        run: |
          max_attempts=30
          attempt=0
          health_state=""
          new_revision_name="${{ steps.create_new_revision.outputs.new_revision_name }}"

          echo "Waiting for new revision to become healthy..."

          while [ "$health_state" != "Healthy" ] && [ $attempt -lt $max_attempts ]; do

            health_state=$(az containerapp revision list \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --query "[?contains(name, '$new_revision_name')].{Health:properties.healthState}|[0].Health" -o tsv)

            echo "::notice:: Current health state: $health_state (attempt $((attempt+1))/$max_attempts)"

            if [ "$health_state" == "Healthy" ]; then
              echo "::notice:: New revision is now healthy!"
              break
            fi

            attempt=$((attempt+1))
            sleep 3
          done

          if [ "$health_state" != "Healthy" ]; then
            echo "error: New revision did not become healthy within the timeout period"
            exit 1
          fi

      - name: Check for New Revision Errors and Increment Traffic
        if: ${{ steps.get_revision_mode.outputs.revision_mode == 'Multiple' && steps.create_new_revision.outputs.skip_remaining_steps == 'false' }}
        run: |
          new_revision_name=${{ steps.create_new_revision.outputs.new_revision_name }}

          for percentage in 5 10 30 60 90 100
          do
            echo "Setting $new_revision_name traffic to $percentage%"

            az containerapp ingress traffic set \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --revision-weight ${{ steps.get_current_revision.outputs.current_revision_name }}=$(100-$percentage) \
              --revision-weight $new_revision_name=$percentage

            echo "Waiting 90 seconds before increasing traffic..."
            sleep 90

            # last_check=$(date +'%Y-%m-%dT%H:%M:%S')"

            # Check for error logs
            # if ([[ -z "${{ env.NPM_SCRIPT }}" ]]); then
            #   error_count=$(az monitor log-analytics query \
            #     --workspace ${{ steps.get_log_analytics_workspace_id.outputs.log_analytics_workspace_id}}) \
            #     --analytics-query "ContainerAppLog_CL | where TimeGenerated between (datetime(2025-01-01T) .. datetime(2025-05-30)) and RevisionName_s == '$new_revision_name' | where Log_s contains 'error' or Log_s contains 'Error' or Log_s contains 'ERROR' or Log_s contains 'exception' or Log_s contains 'Exception'" \
            # else
            #   echo "Running NPM script to check for errors..."
            #   error_count=$(npm run ${{ env.NPM_SCRIPT }})
            # fi

            # Check revision health state
            # health_state=$(az containerapp revision list \
            #   --name ${{ env.CONTAINER_APP_NAME }}  \
            #   --query "[?name=='$new_revision_name'].properties.healthState" -o tsv)

            # echo "Health check results:"
            # echo "- Error logs: $error_count"
            # echo "- Health state: $health_state"

            # If any errors or unhealthy state, rollback and exit
            # if [ "$error_count" -gt 0 ] || [ "$health_state" != "Healthy" ]; then
            #   echo "::error::Errors detected in revision '$new_revision_name', rolling back to previous revision"

            #   az containerapp ingress traffic set \
            #     --name ${{ env.CONTAINER_APP_NAME }} \
            #     --revision-weight ${{ steps.get_current_revision.outputs.current_revision_name }}=100 \
            #     --revision-weight $new_revision_name=0

            #   exit 1
            # fi

            # echo "No errors detected, continuing traffic shift"
          done

          echo "::notice::Successfully shifted 100% traffic to new revision"

      - name: Deactivate old revision
        if: ${{ steps.get_revision_mode.outputs.revision_mode == 'Multiple' && steps.create_new_revision.outputs.skip_remaining_steps == 'false' }}
        run: |
          az containerapp revision deactivate \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --revision ${{ steps.get_current_revision.outputs.current_revision_name }}
