on:
  workflow_call:
    inputs:
      dockerfile_path:
        type: string
        required: false
        default: './Dockerfile'
        description: Dockerfile path
      dockerfile_context:
        type: string
        required: false
        default: '.'
        description: Dockerfile build context
      docker_image_name:
        type: string
        required: false
        default: ${{ github.repository }}
        description: Docker image name, defaults to repository name
      docker_image_description:
        type: string
        required: true
        description: A description to use as image label
      docker_image_authors:
        type: string
        required: false
        default: PagoPA
        description: Authors names to use as image label
      build_args:
        description: List of build arguments to use for Dockerfile build, given in env=value format.
        type: string
        required: false
      build_platforms:
        type: string
        required: false
        default: linux/amd64
        description: Image runtime platform, supports multiple values
      container_app:
        type: string
        required: true
        description: Name of the container app to deploy
      resource_group_name:
        type: string
        required: true
        description: Name of the resource group of the container app
      apply_github_tags_to_image_tags:
          type: boolean
          required: false
          default: false
          description: Use GitHub tags for image tagging
        # override_github_environment:

concurrency:
  group: ${{ github.workflow }}-cd
  cancel-in-progress: true

env:
  IMAGE_NAME: ${{ inputs.docker_image_name }}

jobs:
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    # if: ${{ false }}
    permissions:
      contents: read
      id-token: write
      attestations: write
      packages: write

    steps:

      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        name: Checkout

      - name: Docker Build and Push
        id: docker_build
        uses: pagopa/dx/.github/actions/docker-build-push@CES-958-definire-una-pipeline-di-cd-per-le-container-app
        with:
          dockerfile_path: ${{ inputs.dockerfile_path }}
          dockerfile_context: ${{ inputs.dockerfile_context }}
          docker_image_name: ${{ env.IMAGE_NAME }}
          docker_image_description: "${{ inputs.docker_image_description }}"
          docker_image_authors: ${{ inputs.docker_image_authors }}
          build_args: ${{ inputs.build_args }}
          build_platforms: ${{ inputs.build_platforms }}
          push_to_registry: true
          apply_github_tags_to_image_tags: ${{ inputs.apply_github_tags_to_image_tags}}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release:
    name: Deploy To Container App
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
      id-token: write
    env:
      ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      CONTAINER_APP_NAME: ${{ inputs.container_app }}
      RESOURCE_GROUP_NAME: ${{ inputs.resource_group_name }}

    steps:

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Get Short SHA of Latest Commit
        id: get_commit_sha
        run: |
          sha=$(git rev-parse --short ${{ github.sha }})

          echo "Using sha: $sha"

          echo "short_sha=$sha" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: pagopa/dx/.github/actions/azure-login@main

      - name: Install containerapp AZ CLI Extension
        run: |
          az extension add -n containerapp --yes --allow-preview
          az configure --defaults group=${{ env.RESOURCE_GROUP_NAME }}

      - name: Ensure Latest Revision Captures All Traffic
        id: ensure_latest_revision
        run: |

          current_revision=$(az containerapp revision list \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --query 'reverse(sort_by([].{Revision:name,Active:properties.active,Created:properties.createdTime}[?Active!=`false`], &Created))| [0].Revision' -o tsv)

          az containerapp ingress traffic set \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --revision-weight $current_revision=100

          echo "current_revision_name=$current_revision" >> $GITHUB_OUTPUT

      - name: Create New Revision
        id: create_new_revision
        env:
          CURRENT_REVISION: ${{ steps.ensure_latest_revision.outputs.current_revision_name }}
        run: |
          echo "::notice::Current revision: ${{ env.CURRENT_REVISION}}"

          new_revision=$(az containerapp revision copy \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --from-revision ${{ env.CURRENT_REVISION }} \
            --image "ghcr.io/${{ env.IMAGE_NAME }}:sha-${{ steps.get_commit_sha.outputs.short_sha }}" \
            --query "properties.latestRevisionName" \
            --output tsv)

          echo "::notice:: New revision: $new_revision"

          if [ "$new_revision" == "${{ env.CURRENT_REVISION }}" ]; then
            echo "::notice:: No deployment needed - current revision is already using the latest image"
            echo "skip_remaining_steps=true" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "new_revision_name=$new_revision" >> $GITHUB_OUTPUT
            echo "current_revision_name=${{ env.CURRENT_REVISION }}" >> $GITHUB_OUTPUT
            echo "skip_remaining_steps=false" >> $GITHUB_OUTPUT
          fi

      - name: Wait for New Revision to Become Ready
        if: ${{ steps.create_new_revision.outputs.skip_remaining_steps == 'false' }}
        run: |
          max_attempts=30
          attempt=0
          health_state=""
          new_revision_name="${{ steps.create_new_revision.outputs.new_revision_name }}"

          echo "Waiting for new revision to become healthy..."

          while [ "$health_state" != "Healthy" ] && [ $attempt -lt $max_attempts ]; do

            health_state=$(az containerapp revision list \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --query "[?contains(name, '$new_revision_name')].{Health:properties.healthState}|[0].Health" -o tsv)

            echo "::notice:: Current health state: $health_state (attempt $((attempt+1))/$max_attempts)"

            if [ "$health_state" == "Healthy" ]; then
              echo "::notice:: New revision is now healthy!"
              break
            fi

            attempt=$((attempt+1))
            sleep 1
          done

          if [ "$health_state" != "Healthy" ]; then
            echo "error: New revision did not become healthy within the timeout period"
            exit 1
          fi

      - name: Check for errors and increment traffic
        if: ${{ false }} # if: ${{ steps.create_new_revision.outputs.skip_remaining_steps == 'false' }}
        run: |
          new_revision_name=${{ steps.create_new_revision.outputs.new_revision_name }}

          for percentage in 5 10 30 50 70 90 100
          do
            echo "Setting $new_revision_name traffic to $percentage%"

            az containerapp ingress traffic set \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --revision-weight ${{ steps.ensure_latest_revision.outputs.current_revision_name }}=$(100-$percentage) \
              --revision-weight "$new_revision_name=$percentage"

            echo "Waiting 90 seconds before checking health and increasing traffic..."
            sleep 90

            # Check for error logs
            error_count=$(az containerapp logs show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --revision $new_revision_name \
              --tail 100 \
              # --only-show-errors \
              --format json \
              --query "length([?contains(log, 'error') || contains(log, 'Error') || contains(log, 'ERROR') || contains(log, 'exception') || contains(log, 'Exception')])" \
              --output tsv)

            # Check HTTP errors rate (5xx)
            http_errors=$(az monitor metrics list \
              --resource "$CONTAINER_APP_ID" \
              --metric "HttpResponseStatus5xx" \
              --interval 1m \
              --aggregation Total \
              --output tsv \
              --query 'value[0].timeseries[0].data[0].total' 2>/dev/null || echo "0")

            # Check revision health state
            health_state=$(az containerapp revision list \
              --ids "$CONTAINER_APP_ID" \
              --query "[?name=='$blue_revision'].properties.healthState" -o tsv)

            echo "Health check results:"
            echo "- Error logs: $error_count"
            echo "- HTTP 5xx errors: $http_errors"
            echo "- Health state: $health_state"

            # If any errors or unhealthy state, rollback and exit
            if [ "$error_count" -gt 0 ] || [ "$http_errors" -gt 0 ] || [ "$health_state" != "Healthy" ]; then
              echo "Errors detected in revision '$new_revision_name', rolling back to previous revision"

              az containerapp ingress traffic set \
                --name ${{ env.CONTAINER_APP_NAME }} \
                --label-revision latest=100"

              exit 1
            fi

            echo "No errors detected, continuing traffic shift"
          done

          echo "Successfully shifted 100% traffic to new revision"

      - name: Deactivate old revision
        if: ${{ steps.create_new_revision.outputs.skip_remaining_steps == 'false' }}
        run: |
          az containerapp revision deactivate \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --revision ${{ steps.ensure_latest_revision.outputs.current_revision_name }}
